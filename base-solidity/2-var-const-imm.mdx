---
title: å˜é‡ï¼Œå¸¸é‡ï¼Œä¸å˜é‡
---
# å˜é‡ï¼Œå¸¸é‡ï¼Œä¸å˜é‡

## å˜é‡
å˜é‡æ˜¯Solidityä¸­æœ€å¸¸è§çš„å†…å®¹ï¼Œå®ƒå¯ä»¥ç”¨æ¥å‚¨å­˜éœ€è¦ä¿®æ”¹çš„æ•°æ®ï¼ŒåŒ…æ‹¬é•¿æœŸå­˜å‚¨å’Œä¸´æ—¶å­˜å‚¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡åˆ†ä¸º3ç±»ï¼Œå†…å­˜å˜é‡ï¼ŒçŠ¶æ€å˜é‡ï¼Œå’Œå…¨å±€å˜é‡ã€‚
- å†…å­˜å˜é‡ï¼šå½“åœ¨å‡½æ•°ä¸­å£°æ˜å˜é‡æ—¶ï¼Œå¤§å¤šæ•°æƒ…å†µéƒ½æ˜¯å†…å­˜å˜é‡ï¼Œè¿™äº›åœ¨ä¸€èˆ¬æƒ…å†µä¸‹è¿™äº›å˜é‡å°†ä¼šåœ¨å‡½æ•°æ‰§è¡Œå®Œæˆåè¢«é”€æ¯
- çŠ¶æ€å˜é‡ï¼šå½“åœ¨å‡½æ•°å¤–å£°æ˜å˜é‡æ—¶ï¼Œä¾¿æ˜¯å‚¨å­˜åœ¨åŒºå—é“¾ä¸Šçš„å˜é‡ï¼Œå’Œå†…å­˜å˜é‡ä¸åŒï¼Œä»–ä¼šå‚¨å­˜åœ¨åˆçº¦ä¸­ï¼Œç›´åˆ°åˆçº¦è¢«é”€æ¯ã€‚
- å…¨å±€å˜é‡ï¼šè¿™äº›å˜é‡åœ¨è¿è¡Œæ—¶ä¼šæä¾›ä¸€äº›ç¯å¢ƒæˆ–è€…ä¸Šä¸‹æ–‡çš„æ•°æ®ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½ä¿®æ”¹è¿™äº›å†…å®¹ã€‚

### å†…å­˜å˜é‡
```sol autorun deploySetting="VarContract"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract VarContract{
    function add() public pure returns(uint){
        uint a = 1; // å£°æ˜ä¸€ä¸ªå†…å­˜å˜é‡
        uint b = 2; // å£°æ˜å¦å¤–ä¸€ä¸ªå†…å­˜å˜é‡
        uint c = a + b; // å°†ä¸¤ä¸ªå†…å­˜å˜é‡ç›¸åŠ 
        return c;
    }
}
```
åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸¤ä¸ªå†…å­˜å˜é‡ï¼Œç„¶åå°†ä»–ä»¬ç›¸åŠ ï¼Œæœ€åè¿”å›ç»“æœã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰å£°æ˜ä»»ä½•çš„çŠ¶æ€å˜é‡ã€‚  
å†…å­˜å˜é‡åœ¨å‡½æ•°è¿è¡Œç»“æŸåä¼šè¢«é”€æ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬é™¤äº†å°†ç»“æœè¿”å›å¤–ï¼Œæ²¡æœ‰å…¶ä»–æ–¹æ³•åœ¨å‡½æ•°å¤–è®¿é—®åˆ°è¿™äº›å˜é‡ã€‚
### çŠ¶æ€å˜é‡
é‚£ä¹ˆå†…å­˜å˜é‡çš„é™åˆ¶ä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›å°†è¿è¡Œç»“æœå‚¨å­˜èµ·æ¥ï¼Œè¦å¦‚ä½•åšå‘¢ï¼Ÿè¿™æ—¶å€™å°±éœ€è¦ç”¨åˆ°çŠ¶æ€å˜é‡äº†ã€‚
```sol autorun deploySetting="StateContract"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract StateContract{
    uint public result; // å£°æ˜ä¸€ä¸ªçŠ¶æ€å˜é‡
    function add() public{
        uint a = 1; // å£°æ˜ä¸€ä¸ªå†…å­˜å˜é‡
        uint b = 2; // å£°æ˜å¦å¤–ä¸€ä¸ªå†…å­˜å˜é‡
        uint c = a + b; // å°†ä¸¤ä¸ªå†…å­˜å˜é‡ç›¸åŠ 
        result = c; // å°†ç»“æœèµ‹å€¼ç»™çŠ¶æ€å˜é‡
    }
}
```
æƒ…åœ¨ç¼–è¾‘å™¨ç¼–è¯‘åï¼Œå…ˆç‚¹å‡»`result()`å‡½æ•°æŸ¥çœ‹ç»“æœï¼Œç„¶åç‚¹å‡»`add()`å‡½æ•°ï¼Œå†ç‚¹å‡»`result()`å‡½æ•°æŸ¥çœ‹ç»“æœï¼Œå¯ä»¥çœ‹åˆ°ï¼ŒçŠ¶æ€å˜é‡çš„å€¼å·²ç»å‘ç”Ÿäº†å˜åŒ–ã€‚

### å…¨å±€å˜é‡
å…¨å±€å˜é‡æ˜¯åœ¨è¿è¡Œæ—¶æä¾›ä¸€äº›ç¯å¢ƒæˆ–è€…ä¸Šä¸‹æ–‡çš„æ•°æ®ï¼Œæ¯”å¦‚æˆ‘ä»¬å¸¸ç”¨çš„`msg.sender`ï¼Œ`msg.value`ï¼Œ`block.timestamp`ç­‰ç­‰ã€‚
```sol autorun deploySetting="GlobalContract"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract GlobalContract{
    function getSender() public view returns(address){
        return msg.sender;
    }
    function getTimestamp() public view returns(uint){
        return block.timestamp;
    }
}
```
## å¸¸é‡
å¸¸é‡æ˜¯ä¸€ç§å›ºå®šçš„æ•°æ®ï¼Œè¿™ç§æ•°æ®åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šï¼Œä¸ä¼šéšç€åˆçº¦çš„è¿è¡Œè€Œæ”¹å˜ã€‚å¹¶ä¸”åœ¨è¯»å–å¸¸é‡æ—¶ä½¿ç”¨çš„GASç›¸æ¯”äºå˜é‡è¦å°‘å¾ˆå¤šã€‚
```sol autorun deploySetting="ConstantContract"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract ConstantContract{
    uint constant a = 1; // å£°æ˜ä¸€ä¸ªå¸¸é‡
    uint b = 2; // å£°æ˜ä¸€ä¸ªå˜é‡
    function add() public view returns(uint){
        uint c = a + b; // å°†ä¸¤ä¸ªå˜é‡ç›¸åŠ 
        return c;
    }
}
```
åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªå¸¸é‡å’Œä¸€ä¸ªå˜é‡ï¼Œç„¶åå°†ä»–ä»¬ç›¸åŠ ï¼Œæœ€åè¿”å›ç»“æœã€‚  
å¸¸é‡å¹¿æ³›çš„ç”¨äºåˆçº¦çš„é…ç½®ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥ç”¨æ¥å£°æ˜ä¸€äº›åˆçº¦çš„åŸºæœ¬ä¿¡æ¯ï¼Œä»»ä½•ä¸ä¼šæ”¹å˜çš„æ•°æ®éƒ½å¯ä»¥ç”¨å¸¸é‡æ¥å£°æ˜ã€‚

## ä¸å˜é‡
ä¸å˜é‡æ˜¯å¸¸é‡çš„æ‹“å±•ï¼Œä»–å…·æœ‰å’Œå¸¸é‡ä¸€æ ·çš„æ€§è´¨ï¼Œä½†æ˜¯å”¯ä¸€ä¸åŒçš„æ˜¯ï¼Œä¸å˜é‡å¯ä»¥åœ¨åˆçº¦çš„æ„é€ å‡½æ•°ä¸­è¿›è¡Œåˆå§‹åŒ–èµ‹å€¼ï¼Œè€Œå¸¸é‡åˆ™ä¸å¯ä»¥ã€‚
```sol autorun deploySetting="ImmutableContract"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract ImmutableContract{
    uint public immutable a; // å£°æ˜ä¸€ä¸ªä¸å˜é‡
    constructor(){
        a = 100; // åˆå§‹åŒ–ä¸å˜é‡
    }
}
```
æˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œä¸å˜é‡å…·æœ‰å’Œå¸¸é‡å®Œå…¨ä¸€æ ·çš„æ€§è´¨ï¼Œå½“ä½ åœ¨è°ƒç”¨ä¸å˜é‡çš„æ—¶å€™ï¼Œä¾ç„¶ä¼šèŠ‚çœgasã€‚

<Challenges>
<Challenges.Header>
## ä¹ é¢˜
</Challenges.Header>

<Challenge title='å†…å­˜å˜é‡å®è·µé¢˜'>
<div className='cl-title'>è¯·å°†ä¸‹æ–¹åˆçº¦æŒ‰ç…§æ³¨é‡Šå†…å®¹å®Œå–„ï¼Œéš¾åº¦ï¼šğŸŒŸğŸŒŸ</div>
<CoEditor runnable={true} deploySetting='TestContract'
test={async (vm,h)=>{
    const data = []
    const contract = h.getMainContract()

    const compute = (x)=>{
        return x*x + 11*x + 24
    }

    const tests = [0,1,3,4,8,12,23,554,1212]

    for(let i = 0;i < tests.length;i++){
        await h.catchRawTest('æ£€éªŒå…¬å¼,è¾“å…¥å€¼ä¸ºï¼š'+i,async()=>{
            await h.checkResult(contract,'simpleMathChallenge(uint256)',[compute(i).toString()],[i])
        },data)
    }

    return h.wrapResult(data)
}}
>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{
    // æ­¤å¤„Xçš„å€¼ä¸ºæ­£æ•´æ•°
    function simpleMathChallenge(uint x) public pure returns(uint){
        // è¯·ä¹¦å†™ä»£ç ï¼ŒæŒ‰ç…§ä½ å‰ä¸¤ç« æ‰€å­¦çš„çŸ¥è¯†ï¼Œå°†ä¸‹é¢ä»£ç è¿è¡Œï¼Œå¹¶ä¸”è¦æ±‚è¿è¡Œçš„ç»“æœç¬¦åˆæ–¹ç¨‹ x^2 + 11x + 24 = 0
        // è¯·æ³¨æ„ï¼Œä½ éœ€è¦ä½¿ç”¨å†…å­˜å˜é‡æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡
        /* è¯·å¼€å§‹ä¹¦å†™ä½ çš„ä»£ç ï¼Œä½ çš„ç›®æ ‡åº”è¯¥æ˜¯ç¼–å†™ a å˜é‡å’Œ b å˜é‡ */
        return (x + a) * (x + b)
    }
}
```
</CoEditor>
<Challenge.Hint>
å¦‚æœä½ æ˜¯å› ä¸ºä¸ä¼šå£°æ˜å˜é‡è€ŒæŸ¥çœ‹æç¤ºï¼Œé‚£ä¹ˆä½ å¯ä»¥é‡æ–°é˜…è¯»ä¸Šé¢çš„å˜é‡ç« èŠ‚ã€‚  
å¦‚æœä½ æ˜¯å› ä¸ºä¸äº†è§£æ•°å­¦å…¬å¼è€ŒæŸ¥çœ‹æç¤ºï¼Œé‚£ä¹ˆä¸‹é¢ä¼šæä¾›ä¸€ä¸ªæ•°å­¦å…¬å¼çš„è§£é‡Šã€‚

è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å› å¼åˆ†è§£é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨åå­—ç›¸ä¹˜æ³•æ¥è§£ç­”ã€‚
$$
(x+a)(x+b) = x^2 + (a+b)x + ab
$$
é€šè¿‡ç®€å•çš„è®¡ç®—ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼Œ$ x^2 + 11x + 24 = 0 $æ˜¯$(x+3)(x+8) = 0$çš„å› å¼åˆ†è§£ç»“æœï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å°† $ a = 3 $ï¼Œ$ b = 8 $è½¬æ¢æˆä»£ç ï¼Œå¹¶å†™å…¥ä»£ç ä¸­ã€‚
</Challenge.Hint>
<Challenge.Solution>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{
    // æ­¤å¤„Xçš„å€¼ä¸ºæ­£æ•´æ•°
    function simpleMathChallenge(uint x) public pure returns(uint){
        uint a = 3;
        uint b = 8;
        return (x + a) * (x + b);
    }
}
```
</Challenge.Solution>
</Challenge>

<Challenge title='çŠ¶æ€é‡å’Œå…¨å±€å˜é‡ç»¼åˆå®è·µé¢˜'>
<div className='cl-title'>è¯·å°†ä¸‹æ–¹åˆçº¦æŒ‰ç…§æ³¨é‡Šå†…å®¹å®Œå–„ï¼Œéš¾åº¦ï¼šğŸŒŸ</div>
<CoEditor runnable={true} deploySetting='TestContract'
test={async(vm,h)=>{
    const data = []
    const contract = h.getMainContract()
    const signer = (await vm.webProvider.listAccounts())[0]

    await h.catchRawTest('æ£€æµ‹Owner',async ()=>{
        await contract.setOwner({from:signer});
        await h.checkResult(contract,'owner()',[signer])
    },data)

    return h.wrapResult(data)
}}
>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{
    address public owner; // å£°æ˜ä¸€ä¸ªçŠ¶æ€é‡
    function setOwner() public {
        // è¯·ç¼–å†™ä»£ç ï¼Œå°†ownerçš„å€¼è®¾ç½®ä¸ºåˆçº¦çš„è°ƒç”¨è€…
    }
}
```
</CoEditor>
<Challenge.Hint>
è¿™ä¸€é¢˜æˆ‘ä»¬éœ€è¦ç”¨çš„çŸ¥è¯†ç‚¹ä¸ºå¯¹çŠ¶æ€é‡çš„è®¾ç½®å’Œå¯¹å…¨å±€å˜é‡çš„ä½¿ç”¨ï¼Œæ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬éœ€è¦çš„æ˜¯`msg.sender`è¿™ä¸ªå…¨å±€å˜é‡ï¼Œä¸è¿‡ï¼Œå®é™…ä¸Š`msg`æ‰æ˜¯ä¸€ä¸ªå˜é‡ï¼Œè€Œ`sender`æ˜¯msgçš„ä¸€ä¸ªå±æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨`msg.sender`æ¥è·å–è°ƒç”¨è€…çš„åœ°å€ã€‚  
å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°†`owner`è®¾ç½®ä¸º`msg.sender`å³å¯ã€‚
</Challenge.Hint>
<Challenge.Solution>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{
    address public owner; // å£°æ˜ä¸€ä¸ªçŠ¶æ€é‡
    function setOwner() public {
        owner = msg.sender;
    }
}
```
</Challenge.Solution>
</Challenge>

<Challenge title="å¸¸é‡å’Œä¸å˜é‡">
<div className='cl-title'>è¯·å°†ä¸‹æ–¹åˆçº¦æŒ‰ç…§æ³¨é‡Šå†…å®¹å®Œå–„ï¼Œéš¾åº¦ï¼šğŸŒŸğŸŒŸğŸŒŸ</div>
<CoEditor runnable={true} deploySetting="TestContract"
test={async(vm,h)=>{
    const data = []
    const contract = h.getMainContract()

    for(let i = 0; i < 3; ++i){
        const signer = await vm.getSignerAddress(i);
        const signerProvider = await vm.getSigner(i)
        let safeAddress;
        await h.catchRawTest(`æ£€æµ‹[${i}]CreateSafeåŠŸèƒ½`,async ()=>{
            await contract.connect(signerProvider).createSafe()
            await h.checkResultCustom(contract,'safeMap(address)',([address])=>{
                if(address !== '0x0000000000000000000000000000000000000000'){
                    safeAddress = address
                    return true
                }
            },[signer])
        },data)

        await h.catchRawTest(`æ£€æµ‹Safe[${safeAddress}]åˆçº¦çš„owner`,async ()=>{
            if(!safeAddress) throw new Error('Safeåˆçº¦åœ°å€ä¸å­˜åœ¨')
            const safeContract = await vm.getContractAt('Safe',safeAddress)
            const result = await safeContract.connect(signerProvider).addCount({from:signer})
            if(result.gasLimit.toNumber() > 51000){
                throw new Error(`Safeåˆçº¦[${safeAddress}]æœŸæœ›gasLimitå°äº51000ï¼Œå®é™…ä¸º${result.gasLimit.toNumber()}`)
            }
        },data)
    }

    return h.wrapResult(data)
}}
>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{

    mapping(address => address) public safeMap; // ç”¨äºå‚¨å­˜ç”¨æˆ·çš„Safeåˆçº¦åœ°å€

    function createSafe() public{
        // æ­¤å¤„ä»£ç åŠŸèƒ½ä¸ºï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„Safeåˆçº¦ï¼Œå¹¶ä¸”å°†åœ°å€å‚¨å­˜åœ¨safeMapä¸­
        safeMap[msg.sender] = address(new Safe(msg.sender));
    }
}

contract Safe{
    /* 
    todo: è¯·ç¼–å†™ä»£ç ï¼Œå®Œæˆéœ€æ±‚ï¼šè¯·é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„é‡ï¼ˆå˜é‡ï¼Œå¸¸é‡ï¼Œä¸å˜é‡ï¼‰å¹¶ä¸”å‘½åä¸ºownerï¼Œç”¨äºå‚¨å­˜Safeåˆçº¦çš„æ‹¥æœ‰è€…
    è¯·æ³¨æ„ï¼Œåœ¨addCountå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¼šè·å–ownerçš„å€¼ï¼Œå¹¶ä¸”é¢˜ç›®é™åˆ¶äº†æœ€å¤šä½¿ç”¨51000gasï¼Œè¯·æ³¨æ„âš ï¸ã€‚
    */

    /* è¯·åœ¨æ­¤å¤„ç¼–å†™ä»£ç  */

    uint public count;
    constructor(address owner_){
        owner = owner_;
    }

    function addCount() public{
        require(owner == msg.sender,"Only owner can add count");
        count += 1;
    }
}
```
</CoEditor>
<Challenge.Hint>
æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œæˆ‘ä»¬éœ€è¦åœ¨Safeåˆçº¦ä¸­æ„é€ çš„æ—¶å€™ï¼Œè®¾å®šownerï¼Œä½†æ˜¯å› ä¸ºè¦æ±‚51000çš„æœ€å¤§gasï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦èŠ‚çœä¸‹æ¥ä¸€äº›gasï¼Œå°†ownerè®¾ç½®ä¸ºä¸å˜é‡æ‰èƒ½ç¬¦åˆé¢˜ç›®å†…å®¹ã€‚
</Challenge.Hint>
<Challenge.Solution>
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract TestContract{
    mapping(address => address) public safeMap;

    function createSafe() public{
        safeMap[msg.sender] = address(new Safe(msg.sender));
    }
}

contract Safe{
    address immutable owner;
    uint public count;

    constructor(address owner_){
        owner = owner_;
    }

    function addCount() public{
        require(owner == msg.sender,"Only owner can add count");
        count += 1;
    }
}
```
</Challenge.Solution>
</Challenge>
</Challenges>